"use strict";(globalThis.webpackChunk_001_physical_ai_textbook_docs=globalThis.webpackChunk_001_physical_ai_textbook_docs||[]).push([[4321],{1238:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"assessments/module3-assessments","title":"module3-assessments","description":"Module 3: Robot Kinematics and Dynamics - Assessment Ideas","source":"@site/docs/assessments/module3-assessments.md","sourceDirName":"assessments","slug":"/assessments/module3-assessments","permalink":"/Project-Hackathon-I/docs/assessments/module3-assessments","draft":false,"unlisted":false,"editUrl":"https://github.com/MohammadNoman/Project-Hackathon-I/tree/master/frontend/docs/assessments/module3-assessments.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Module 2: Robot Sensing and Perception - Assessments","permalink":"/Project-Hackathon-I/docs/assessments/module2-assessments"},"next":{"title":"Module 4: Robot Motion Planning and Control - Assessments","permalink":"/Project-Hackathon-I/docs/assessments/module4-assessments"}}');var t=s(4848),o=s(8453);const r={},a=void 0,c={},l=[{value:"Module 3: Robot Kinematics and Dynamics - Assessment Ideas",id:"module-3-robot-kinematics-and-dynamics---assessment-ideas",level:3}];function d(e){const n={code:"code",h3:"h3",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h3,{id:"module-3-robot-kinematics-and-dynamics---assessment-ideas",children:"Module 3: Robot Kinematics and Dynamics - Assessment Ideas"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"I. Quizzes (Short Answer/Multiple Choice with AI-Assisted Feedback)"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Kinematics vs. Dynamics (Concepts and Application)"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Question:"})," A robot arm is designed to pick and place objects. Which branch of mechanics (kinematics or dynamics) would primarily be concerned with ensuring the arm can reach all necessary positions, and which would be concerned with the forces required to move objects quickly without wobbling?"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"AI-Native Feedback:"}),' If the student correctly identifies "kinematics for reaching positions" and "dynamics for forces/wobbling," the AI can provide a simple confirmation. If incorrect, it can guide them to review sections 1.1.1 and 1.1.2 with specific line numbers (e.g., "Recall the definitions in ',(0,t.jsx)(n.code,{children:"index.md"}),' lines 7-13").']}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Homogeneous Transformations (Structure and Purpose)"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Question:"})," Describe the components of a 4x4 homogeneous transformation matrix ",(0,t.jsx)(n.code,{children:"T"})," and explain how it simultaneously represents position and orientation. Why is this combined representation useful in robotics?"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"AI-Native Feedback:"}),' The AI can check for the presence of "3x3 rotation matrix (R)", "3x1 translation vector (P)", and the "0 1" row. It can then evaluate the explanation against the importance of compact representation and concatenation from section 2.1.']}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Denavit-Hartenberg (DH) Parameters (Identification and Purpose)"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Question:"})," For a simple 2-link planar robot arm with two revolute joints, identify the minimum set of DH parameters needed for each link. Briefly explain how these parameters contribute to the forward kinematics solution."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"AI-Native Feedback:"})," The AI can prompt students to consider ",(0,t.jsx)(n.code,{children:"alpha"}),", ",(0,t.jsx)(n.code,{children:"a"}),", ",(0,t.jsx)(n.code,{children:"d"}),", ",(0,t.jsx)(n.code,{children:"theta"})," and their roles for revolute joints (section 3.1.1). It can also check if the student understands that ",(0,t.jsx)(n.code,{children:"theta"})," would be the variable for revolute joints."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Inverse Kinematics (Challenges and Approaches)"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Question:"})," A 7-DoF robot needs to grasp an object. Why might its inverse kinematics problem have multiple solutions, and what are two main approaches (analytical vs. numerical) to solve it?"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"AI-Native Feedback:"})," The AI can verify understanding of redundancy (section 4.4.1) and the existence of analytical vs. numerical methods (sections 4.1, 4.2)."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Jacobian and Singularities (Consequences)"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Question:"})," What is a robot singularity, and why is it problematic for robot control? How can it be identified and potentially avoided?"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"AI-Native Feedback:"})," The AI can look for explanations about loss of DoF (section 5.2.1) and methods like checking Jacobian rank/determinant or trajectory planning (section 5.2.2)."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Euler-Lagrange vs. Newton-Euler (Conceptual Difference)"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Question:"})," Contrast the Euler-Lagrange and Newton-Euler formulations for robot dynamics based on their fundamental approach (energy vs. force-based)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"AI-Native Feedback:"}),' The AI can confirm "energy-based" for Euler-Lagrange (section 6.1) and "force-based, recursive" for Newton-Euler (section 6.2).']}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"ZMP in Humanoid Locomotion (Application)"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Question:"})," Explain the concept of the Zero Moment Point (ZMP) and its significance for the stable locomotion of humanoid robots."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"AI-Native Feedback:"})," The AI can check for the definition of ZMP as the point of zero net moment and its relation to the support polygon for stability (section 8.2.1)."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"II. Project Prompts (Coding/Simulation-Based with AI-Native Tool Integration)"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Forward Kinematics Implementation and Visualization (Beginner to Intermediate)"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Prompt:"})," Implement the forward kinematics for a 3-link robotic arm (e.g., R-R-P configuration) using Denavit-Hartenberg parameters. Your solution should:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Define the DH parameters for your chosen robot."}),"\n",(0,t.jsx)(n.li,{children:"Write a Python function that takes joint variables as input and returns the end-effector's homogeneous transformation matrix."}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"(AI-Native Extension):"})," Use a robotics library (e.g., ",(0,t.jsx)(n.code,{children:"SciPy"})," for matrix operations, or ",(0,t.jsx)(n.code,{children:"PyBullet"})," for visualization if integrated) to visualize the robot's pose for different joint inputs. The AI can suggest specific code structures or library functions."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Expected Output:"})," Python code, DH parameter table, example end-effector poses."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Assessment Criteria:"})," Correct DH parameter assignment, accurate FK calculation, clear code, successful visualization."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Inverse Kinematics for a Planar Arm (Intermediate)"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Prompt:"})," Develop an analytical inverse kinematics solver for a 2-DoF planar robot arm (R-R configuration).","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Given a desired (x, y) position for the end-effector, calculate the two joint angles (",(0,t.jsx)(n.code,{children:"q1"}),", ",(0,t.jsx)(n.code,{children:"q2"}),")."]}),"\n",(0,t.jsx)(n.li,{children:"Handle cases where multiple solutions exist (e.g., elbow up/down) or no solution (out of reach)."}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"(AI-Native Extension):"})," The AI can help debug trigonometric functions, suggest unit tests for boundary conditions, or point to relevant sections on geometric IK (section 4.1.2)."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Expected Output:"})," Python code, test cases covering different scenarios, explanation of solution handling."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Assessment Criteria:"})," Correct analytical derivation, accurate angle calculation, proper handling of multiple/no solutions."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Robot Dynamics Simulation (Advanced)"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Prompt:"})," Using a robotics simulation environment (e.g., ",(0,t.jsx)(n.code,{children:"PyBullet"}),", ",(0,t.jsx)(n.code,{children:"MuJoCo"}),", or a custom physics engine), model a 2-link robotic arm and simulate its dynamics under a simple control law.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Define the mass, inertia, and center of mass for each link."}),"\n",(0,t.jsx)(n.li,{children:"Apply a simple joint torque (e.g., a step input) to one of the joints."}),"\n",(0,t.jsx)(n.li,{children:"Observe and plot the resulting joint accelerations, velocities, and positions over time."}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"(AI-Native Extension):"})," The AI can assist with setting up the simulation environment, interpreting dynamic equations (section 8.1), or suggesting ways to visualize forces and torques. It can also help students debug unexpected simulation behavior by comparing it against theoretical expectations."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Expected Output:"})," Simulation code, plots of joint states, brief analysis of the observed dynamic behavior."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Assessment Criteria:"})," Correct dynamic model setup, accurate simulation results, insightful analysis."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Trajectory Generation and Smoothing (Intermediate to Advanced)"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Prompt:"})," Generate a smooth joint-space trajectory for a 3-DoF robot to move its end-effector between three waypoints.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Use cubic or quintic polynomial interpolation to ensure continuous velocity and/or acceleration."}),"\n",(0,t.jsx)(n.li,{children:"Plot the joint positions, velocities, and accelerations over time."}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"(AI-Native Extension):"})," The AI can help students derive the polynomial coefficients from boundary conditions, suggest plotting libraries, or explain the trade-offs between different polynomial orders (section 9.2.2)."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Expected Output:"})," Python code for trajectory generation, plots of joint kinematics, explanation of the chosen interpolation method."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Assessment Criteria:"})," Smooth trajectory profiles, correct application of polynomial interpolation, adherence to kinematic limits."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"AI-Driven Kinematics/Dynamics (Research/Exploration - Advanced)"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Prompt:"})," Explore a machine learning approach to a challenge in robot kinematics or dynamics. Choose one of the following:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"A."})," Use a simple neural network to learn the forward kinematics of a 2-link planar arm from simulated joint angle/end-effector position data."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"B."})," Investigate how a reinforcement learning agent could learn a simple balancing task for a simulated 1-DoF inverted pendulum (a simplified bipedal balance problem)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"(AI-Native Extension):"})," The AI can suggest relevant ML libraries (e.g., ",(0,t.jsx)(n.code,{children:"TensorFlow"}),", ",(0,t.jsx)(n.code,{children:"PyTorch"}),"), provide starting code snippets for basic network architectures, or guide students on data generation and evaluation metrics. It can also point to section 11.1 for inspiration."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Expected Output:"})," Code (Python with ML library), dataset generation, training and evaluation results, discussion of findings and limitations."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Assessment Criteria:"})," Demonstration of ML application, clear methodology, analysis of results, understanding of AI's role in robotics."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"III. Essay/Discussion Prompts (Conceptual and Critical Thinking)"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Impact of Real-World Complexities (Discussion)"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Prompt:"})," Discuss how factors like friction, backlash, and elasticity (section 10.1.1) in physical robots can cause deviations from theoretical kinematic and dynamic models. Propose potential strategies to mitigate these effects in robot control systems."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"AI-Native Textbook Integration:"})," The AI can facilitate a discussion, pointing out different mitigation strategies and their pros/cons, or asking follow-up questions to deepen understanding."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Advantages of Redundancy (Critical Thinking)"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Prompt:"})," While redundancy complicates inverse kinematics, it offers significant advantages for advanced robot tasks. Explain how a redundant robot could utilize its extra degrees of freedom to achieve secondary objectives like obstacle avoidance or singularity avoidance, using the concepts from section 4.4.2."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"AI-Native Textbook Integration:"})," The AI can challenge students to think of novel ways to exploit redundancy or compare different optimization criteria."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Future of Robot Dynamics (Visionary)"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Prompt:"}),' Based on the "Future Trends" discussed in Module 3 (Section 11), select two trends (e.g., AI-Driven Kinematics/Dynamics, Soft Robotics, Human-Robot Collaboration) and elaborate on how they will fundamentally change the way robots are designed, controlled, and interact with their environment.']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"AI-Native Textbook Integration:"})," The AI can help students synthesize information from different subsections, connect trends to real-world applications, and encourage imaginative but grounded predictions."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"These assessments aim to cover both theoretical understanding and practical application, with the AI-Native Textbook offering dynamic support and feedback to enhance the learning experience."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>a});var i=s(6540);const t={},o=i.createContext(t);function r(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);